// React
import React from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { merge } from 'lodash';
// Material UI
import RefreshIndicator from 'material-ui/RefreshIndicator';
// Components
import AssignedTaskIndex from '../../components/tasks/assigned_task_index';
// Actions
import { fetchAssignedTaskList, updateAssignedTask } from '../../actions/task_http_actions';
import { updateAssignedTaskViaSocket } from '../../actions/task_socket_actions';
// Enums
const refreshIndicatorStyle = {
  position: 'relative'
};
const Status = {
  READY: 'ready',
  LOADING: 'loading',
  HIDE: 'hide'
};


class TaskOverview extends React.Component {
  state = {
    socketConnectionStatus: Status.LOADING
  };

  static propTypes = {
    dispatchUpdateAssignedTask: PropTypes.func.isRequired,
    dispatchUpdateAssignedTaskViaSocket: PropTypes.func.isRequired,
    dispatchFetchAssignedTaskList: PropTypes.func.isRequired,
    currentUser: PropTypes.object.isRequired,
    assignedTasks: PropTypes.object.isRequired
  };

  // TODO: Is it possible to have server send me a custom greeting message when connection is opened?
  handleChannelOnConnect = () => {
    this.setState({ socketConnectionStatus: Status.READY });
    this.socket.perform('received', { message: 'Hello' });
  };

  handleChannelOnDisconnect = (msg) => {
    this.setState({ socketConnectionStatus: Status.LOADING });
    console.log('Channel is closed', msg);
  }

  handleChannelOnReceive = (payload) => {
    // TODO: Please use enums
    switch (payload.status) {
      case 'updated':
        if (this.props.assignedTasks[payload.id]) {
          delete payload.status;
          this.props.dispatchUpdateAssignedTaskViaSocket(merge({}, this.props.assignedTasks[payload.id], payload));
        }
        break;
      default:
    }
  }

  componentDidMount() {
    const channelParams = {
      channel: 'TasksChannel',
      current_user_id: this.props.currentUser.id
    };

    const channelHandlers = {
      received: this.handleChannelOnReceive,
      connected: this.handleChannelOnConnect,
      disconnected: this.handleChannelOnDisconnect
    };

    // Holy shit, App.cable is auto-generated by Rails!!!
    this.socket = App.cable.subscriptions.create(channelParams, channelHandlers);
    this.props.dispatchFetchAssignedTaskList(this.props.currentUser.id);
  }

  render() {
    return (
      <div className="task-overview">
        <section className="title">
          <h1>Task Overview</h1>
          <RefreshIndicator
            status={this.state.socketConnectionStatus}
            style={refreshIndicatorStyle}
            top={0}
            left={0} />
        </section>
        <AssignedTaskIndex
          assignedTasks={this.props.assignedTasks}
          dispatchUpdateAssignedTask={this.props.dispatchUpdateAssignedTask}
          currentUser={this.props.currentUser} />
      </div>
    );
  }
}

const mapStateToProps = (state) => ({
  currentUser: state.sessions.currentUser,
  assignedTasks: state.tasks.assigned
});

const mapDispatchToProps = (dispatch) => ({
  dispatchUpdateAssignedTask: (task) => dispatch(updateAssignedTask(task)),
  dispatchFetchAssignedTaskList: (userId) => dispatch(fetchAssignedTaskList(userId)),
  dispatchUpdateAssignedTaskViaSocket: (task) => dispatch(updateAssignedTaskViaSocket(task))
});

export default connect(mapStateToProps, mapDispatchToProps)(TaskOverview);
